> 参考来源：
>
> 康师傅：https://www.bilibili.com/video/BV1iq4y1u7vj?p=112
>
> 爱编程的大李子：https://blog.csdn.net/LXYDSF/article/details/125755327

# 一、数据库缓冲池（buffer pool）

InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页 面(包括读页面、写页面、创建新页面等操作)。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操 作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访 问。

这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提 升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。


> 缓冲池 vs 查询缓存
>
> 缓冲池和查询缓存是一个东西吗？不是。

## 1. 缓冲池（Buffer Pool）

**缓冲池的组成:**

- InnoDB缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应Hash和数据字典信息等。

**缓存池的重要性:**

- 对于使用`InnoDB`作为存储引擎的表来说,不管是用于存储用户数据的索引(包括聚簇索引和二级索引)，还是各种系统数据，都是以`页`的形式存放在`表空间`中的,而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的跟乌龟一样,怎么能配得上“`快如风，疾如电`”的CPU呢?这里，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以InnoDB存储弓|擎在处理客户端的请求时，当需要访问某个页的数据时，就会把`完整的页的数据全部加载到内存中`，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉,而是将其`缓存`起来,这样将来有请求再次访问该页面时，就可以`省去磁盘I0`的开销了。

  

**缓存原则：**

- “`位置 * 频次` ”这个原则，可以帮我们对 I/O 访问效率进行优化。 首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。

- 其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 `优先对使用频次高的热数据进行加载`。
  

**缓冲池的预读特性:**

- 缓冲池的作用就是提升I/0效率，而我们进行读取数据的时候存在一个“局部性原理”， 也就是说我使用了一些数据，`大概率还会使用它周围的一些数据`，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘1/O操作。

## 2. 缓冲池如何读取数据

缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。

> 如果我们执行SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗?
>
> 实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息,然后数据库会以一定的频率刷新到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做checkpoint的机制将数据回写到磁盘上,这样做的好处就是提升了数据库的整体性能。
>
> 比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，将不常用的脏页回写到磁盘上,然后再从缓冲池中将这些页释放掉。这里脏页(dirty page)指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。
> 

## 3. 查看/设置缓冲池的大小

如果你使用的是MySQL MyISAM存储引擎,它只缓存索引， 不缓存数据，对应的键缓存参数 `key_buffer_size`，你可以用它进行查看。

如果你使用的是InnoDB存储引擎，可以通过查看 `innodb_buffer_pool_size` 变量来查看缓冲池的大小。命令如下:

```mysql
# 查看InnoDB缓冲池的大小，单位Byte
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';

# 设置缓冲池大小为256MB
SET GLOBAL innodb_buffer_pool_size = 268435456;

# 或者在配置文件中修改
[server]
innodb_buffer_pool_size = 268435456
```

## 4. 多个Buffer Pool实例

Buffer Pool本质是InnoDB向操作系统申请的一块`连续的内存空间`，在多线程环境下，访问Buffer Pool中的数据都需要加锁处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们`拆分成若干个小的Buffer Pool` ，每个Buffer Pool都称为一个`实例`，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。

我们可以在配置文件中修改`innodb_buffer_pool_instances`的值并重启MySQL来修改Buffer Pool实例的个数

```mysql
[server]
innodb_buffer_pool_instances = 2
```

这样就表明我们要创建2个 `Buffer Pool` 实例。

查看缓冲池的个数，使用命令:

```mysql
# 查看缓冲池的个数
SHOW VARIABLES LIKE 'innodb_buffer_pool_instances';
```

每个 Buffer Pool 实例实际占的内存空间为：`innodb_buffer_pool_size/innodb_buffer_pool_instances`
也就是总共的大小除以实例的个数，结果就是每个`Buffer Pool` 实例占用的大小。

不过也不是说Buffer Pool实例创建的越多越好，分别`管理各个Buffer Pool也是需要性能开销`的，InnoDB规定:当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_ buffe _pool_instances 的值修改为1。而我们鼓励在Buffer Ppol大于或等于1G的时候设置多个Buffer Pool实例。


> 引申问题
>
> Buffer Pool 是 MySQL 内存结构中十分核心的一个组成。当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在,存储弓|擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端;同理，当我们更新某个数据的时候，如果这个数据不存在于Buffer Pool,同样会先数据加载进来，然后修改修改内存的数据。被修改过的数据会在之后统一刷入磁盘。


