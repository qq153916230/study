> 参考来源：
>
> 康师傅：https://www.bilibili.com/video/BV1iq4y1u7vj?p=118
>
> 爱编程的大李子：https://blog.csdn.net/LXYDSF/article/details/125873790

# 一、聚簇索引

特点：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义:
   - **页内** 的记录是按照主键的大小顺序排成一个 **单向链表** 
   - 各个存放 **用户记录的页**，也是根据页中用户记录的主键大小顺序排成一个 **双向链表**
   - 存放**目录项记录**的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个**双向链表**
2. **B+ 树的叶子节点存储的是完整的用户记录**。
   所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为**聚簇索引**，所有**完整的用户记录**都存放在这个聚簇索引的**叶子节点**处。这种聚簇索引并不需要我们在MySQL语句中显式的使用**INDEX**语句去创建，**InnoDB**存储引擎会**自动**的为我们创建聚簇索引。

**优点：**

- **数据访问更快** ，因为聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对于主键的 **排序查找** 和 **范围查找** 速度非常快 (因为数据本身就是有序的)
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 **节省了大量的 io 操作** 。
  

**缺点:**

- **插入速度严重依赖于插入顺序** ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个**自增的 ID 列为主键**
  - 前半句分析。当在两个页中间插入数据时，就会导致后面页进行逻辑上的移动，然后插入新数据。同时上层目录页中的数据以及指针也可能变动，依次往上推，从而会降低性能！
  - 后半句思考：删除的时候通常不真正删除，而是弄一个删除标记是不是和这个有关？
- 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义**主键为不可更新**
- **二级索引访问需要两次索引查找** ，第一次找到主键值，第二次根据主键值找到行数据（回表）

**限制：**

- 对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MylSAM并不支持聚簇索引。
- 由于数据物理存储排序方式只能有一种，所以每个MySQL的**表只能有一个聚簇索引**。一般情况下就是该表的主键。
- 如果没有定义主键，Innodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。
- 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id,比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。

# 二、二级索引

也称为辅助索引、非聚簇索引。非主键创建的索引称为二级索引。

聚簇索引的叶子节点存储的是完整的用户记录，而二级索引的叶子节点存储的是主键，所以查询需要两次索引查找。

> 概念：**回表** 我们根据这个以 `非主键列`大小排序的 B+ 树只能确定我们要查找记录的主键值，所以如果我们想根据 `非主键列`的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据 `非主键列`的值查询一条完整的用户记录需要使用到 2 棵 B+ 树！

# 三、联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 **c2 和c3** 列 的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照 c2 列进行排序。
- 在记录的 c2 列相同的情况下，采用 c3 列进行排序

以 c2 和 c3 列的大小为排序规则建立的 B+ 树称为 **联合索引** ，本质上也是一个二级索引