> 参考来源：
>
> 康师傅：https://www.bilibili.com/video/BV1iq4y1u7vj?p=125
>
> 爱编程的大李子：https://blog.csdn.net/LXYDSF/article/details/125974218

# 一、指定行格式的语法

指定行格式的语法

```mysql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称 # 创建
ALTER TABLE 表名 ROW_FORMAT=行格式名称 # 修改
```

# 二、行格式类型

## 1. COMPACT

在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分

![](https://raw.githubusercontent.com/qq153916230/study/main/mysql/pic/56.png)

- **变长字段长度列表**

  MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为**变长字段**，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个**变长字段长度列表**。

  注意：这里面存储的变长长度和字段**顺序是反过来的**。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。

- **NULL值列表**

  Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。

  **为什么定义NULL值列表？**

  之所以要存储NULL是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：

  - 二进制位的值为1时，代表该列的值为NULL。
  - 二进制位的值为0时，代表该列的值不为NULL。

- **记录头信息**（5字节）

  ![](https://raw.githubusercontent.com/qq153916230/study/main/mysql/pic/57.png)

  - delete_mask

    这个属性标记着当前记录是否被删除，占用1个二进制位。

    - 值为0：代表记录并没有被删除
    - 值为1：代表记录被删除掉了

  - min_rec_mask

    B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。

  - record_type

    这个属性表示当前记录的类型，一共有4种类型的记录：

    - 0：表示普通记录
    - 1：表示B+树非叶节点记录
    - 2：表示最小记录
    - 3：表示最大记录

  - heap_no

    这个属性表示当前记录在本页中的位置。

    新插入的数据序号从2开始依次递增2.3.4.5...

    怎么不见heap_no值为0和1的记录呢？

    MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为**伪记录**或者**虚拟记录**。这两个伪记录一个代表**最小记录**，一个代表**最大记录**。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。

  - n_owned

    页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。 详情见page directory。

  - next_record

    记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的**地址偏移量**。

- 记录的真实数据

  记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：

  | 列名           | 是否必须 | 占用空间 | 描述                   |
  | -------------- | -------- | -------- | ---------------------- |
  | row_id         | 否       | 6字节    | 行ID，唯一标识一条记录 |
  | transaction_id | 是       | 6字节    | 事务ID                 |
  | roll_pointer   | 是       | 7字节    | 回滚指针               |

  实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。

  - 一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。
  - 事务ID和回滚指针在后面的MySQL事务日志章节中再描述。

查看Compact行记录的内部结构可以在Windows操作系统下，通过应用NodePad++打开表空间文件xx.ibd这个二进制文件查看

![](https://raw.githubusercontent.com/qq153916230/study/main/mysql/pic/58.png)

## 2. Dynamic和Compressed行格式

- 行溢出

  InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。

  我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为**行溢出**

在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行**分页存储**，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。

在MySQL 8.0中，**默认行格式就是Dynamic**，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：

- Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。
- Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。

## 3. Redundant行格式

Redundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持Redundant是为了兼容之前版本的页格式。