> 参考来源：
>
> 康师傅：https://www.bilibili.com/video/BV1iq4y1u7vj?p=121
>
> 爱编程的大李子：https://blog.csdn.net/LXYDSF/article/details/125974218

# 一、概述

**页**(Page)是磁盘与内存交互基本单位，是数据库管理存储空间的基本单位 , 也是数据库I/O操作的最小单位。InnoDB将数据划分为若干个页，InnoDB中页的大小默认为**16KB**。在数据库中，不论读一行, 还是读多行，都是将这些行所在的页进行加载，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。一个页中可以存储多个行记录。

页a、页b、页c ..页n这些页可以**不在物理结构上相连**，只要通过**双向链表**相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个**单向链表**，每个数据页都会为存储在它里边的记录生成一个**页目录**，在通过主键查找某条记录的时候可以在页目录中**使用二分法**快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

## 1. 页的上层结构：

在数据库中，还存在着区(Extent)、段(Segment)和表空间(Tablespace)的概念。行、页、区、段、表空间的关系如下图所示:

![](D:\mine\study\mysql\pic\49.png)

- 区(Extent)是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配**64个连续的页**。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB= 1MB。
- 段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间(在InnoDB中是连续的64个页)不过在段中不要求区与区之间是相邻的。**段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在**。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。
- 表空间(Tablespace)是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为**系统表空间、用户表空间、撤销表空间、临时表空间**等。

## 2. 页的内部结构：

页如果按类型划分的话，常见的有**数据页**（保存B+树节点)、**系统页**、**Undo页**和**事务数据页**等。数据页是我们最常使用的页。

数据页的16KB大小的存储空间被划分为七个部分，分别是文件头(File Header)、页头(Page Header)、最大最小记录(Infimum+supremum)、用户记录(User Records)、空闲空间(Free Space)、页目录(Page Directory）和文件尾(File Tailer) 。

页结构的示意图如下所示:

![](D:\mine\study\mysql\pic\50.png)

### 2.1 File Header（文件头部）

**作用：**描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）
**构成：**
![](D:\mine\study\mysql\pic\51.png)

- **FIL_PAGE_OFFSET（4字节）**
  每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。

- **FIL_PAGE_TYPE（2字节）**

  这个代表当前页的类型，如下
  

  ![](D:\mine\study\mysql\pic\52.png)

  

- **FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）**

  InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。

- **FIL_PAGE_SPACE_OR_CHKSUM（4字节）**

  文件头部和文件尾部都有属性作用：

  **作用：**

  InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。

  每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。这里，校验方式就是采用 Hash 算法进行校验。
  

### 2.2 File Trailer（文件尾部）

- **前4个字节代表页的校验和：**

  这个部分是和File Header中的校验和相对应的。

- **后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：**

  这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。

### 2.3 Free Space (空闲空间)

我们自己存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。


### 2.4 User Records (用户记录)

User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表。

### 2.5 Infimum + Supremum（最小最大记录）

InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示：

![](D:\mine\study\mysql\pic\53.png)

这两条记录不是我们自己定义的记录，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分，如图所示：

![](D:\mine\study\mysql\pic\54.png)

### 2.6 Page Directory（页目录）

在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。

使用页目录，二分法查找：

1. 将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。

   - 第 1 组，也就是最小记录所在的分组只有 1 个记录；
   - 最后一组，就是最大记录所在的分组，会有 1-8 条记录；
   - 其余的组记录数量在 4-8 条之间。

   这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分。

2. 在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。

3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。
   

### 2.7 Page Header（页面头部）

为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。

![](D:\mine\study\mysql\pic\55.png)


- **PAGE_DIRECTION**
  假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION。
- **PAGE_N_DIRECTION**
  假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

